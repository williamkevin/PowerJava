# Chapter 06 상속

## 6.1 상속

- 상속(Inheritance): 기존에 존재하는 클래스로부터 필드와 메서드를 이어받고, 필요한 기능을 추가할 수 있는 기법

### 상속의 형식

- 부모 클래스(슈퍼 클래스): 상속하는 클래스
- 자식 클래스(서브 클래스): 상속받는 클래스
- 키워드 extends를 사용한다.

```java
class Car {
    int speed;
    public void setSpeed(int speed) {
        this.speed = speed;
    }
}

public class ElectricCar extends Car{
    int battery;
    public void charge(int amount) {
        battery += amount;
    }
}
```

### 무엇이 상속되는가?

- 자식 클래스는 부모 클래스가 가지고 있는 모든 멤버들을 상속받고 자신이 필요한 멤버를 추가하기 때문에 항상 자식 클래스가 부모 클래스를 포함하게 된다.
- 상속을 나타낼 때 extends(확장)라는 용어를 사용하는 것도 이것 때문이다.

```java
public class ElectricCarTest {
    public static void main(String args[]) {
        ElectricCar obj = new ElectricCar();
        obj.speed = 10; // 부모 클래스의 필드에 접근한다.
        obj.setSpeed(60); // 부모 클래스의 메소드에 접근한다.
        obj.charge(10); // 자체 메소드에 접근한다.
    }
}
```

### 왜 상속하는가?

1. 필드와 메소드에 대한 코드를 재사용할 수 있다.
2. 중복되는 코드를 줄일 수 있다.

````java
public class Vehicle {
    int speed;
    int heading;

    public void setSpeed(int speed) {
        this.speed = speed;
    }

    public void turn(int angle) {
        heading = angle;
    }
}

class Car extends Vehicle {
    int price;
}

class Truck extends Vehicle {
    int payload;
}

class Bus extends Vehicle {
    int seat;
}
````

### 자바 상속의 특징

자바에서의 상속의 특징

1. 여러 클래스로부터 상속받는 다중 상속을 지원하지 않는다.
2. 상속의 횟수에 제한이 없다.
3. 상속 계층 구조의 최상위에는 java.lang.Object가 있다.

예제 6-1

```java
class Animal {
    int age;
    void eat() {
        System.out.println("먹음");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("짖음");
    }
}

public class DogTest {
    public static void main(String args[]) {
        Dog obj = new Dog();
        obj.eat(); // 먹음
        obj.bark(); // 짖음
    }
}
```

예제 6-2

````java
class Shape {
    int x;
    int y;
}

class Circle extends Shape {
    int radius;

    public Circle(int radius) {
        this.radius = radius;
        x = 0;
        y = 0;
    }

    double getArea() {
        return 3.14 * radius * radius;
    }
}

public class CircleTest {
    public static void main(String args[]) {
        Circle obj = new Circle(10);
        System.out.println("원의 중심: (" + obj.x + ", " + obj.y + ")"); // 원의 중심: (0, 0)
        System.out.println("원의 면적: " + obj.getArea()); // 원의 면적: 314.0
    }
}
````

## 6.2 상속과 접근 지정자

- 접근 지정자를 통해 자식 클래스가 상속받는 멤버를 지정한다.

|         | public | protect | default | private |
|---------|--------|---------|---------|---------|
| 동일한 클래스 | O      | O       | O       | O       |
| 동일한 패키지 | O      | O       | O       | X       |
| 자식 클래스  | O      | O       | O       | X       |
| 다른 패키지  | O      | X       | X       | X       |

````java
class Shpae {
    protected int x, y;


    void print() {
        System.out.println("x좌펴: " + x + " y좌표: " + y);
    }
}


public class Rectangle extends Shape {
    int width, heigh;

    double calcArea() {
        return 3.14 * width * heigh;
    }

    void draw() {
        System.out.println("(" + x + ", " + y + ")" + " 위치에 " + "가로: " + width + "세로: " + heigh);
    }
}
````

예제 6-3

```java
class Person {
    // private String regnumber;
    private double weight;
    protected int age;
    String name;

    double getWeight() {
        return weight;
    } 

    void setWeight(double weight) {
        this.weight = weight;
    }
}

class Student extends Person {
    int id;
}

public class StudentTest {
    public static void main(String args[]) {
        Student obj = new Student();

        // obj.regnumber = '123456 - 1234567'; // 오류
        // obj.weight = 70; // 오류
        obj.age = 23;
        obj.name = "Sewon Kim";
        obj.setWeight(70);

        System.out.println(obj.age + "세"); // 23세
        System.out.println(obj.name); // Sewon Kim
        System.out.println(obj.getWeight() + "kg"); // 70.0kg
    }
}
```

## 6.3 상속과 생성자

- 자식 클래스 객체 안에는 부모 클래스에서 상속된 부분이 들어 있기 때문에 자식 클래스 객체를 생성하면 부모 클래스의 생성자도 호출된다.
- 자식 클래스 객체는 부모 클래스에서 상속된 부분을 초기화하기 위하여 먼저 부모 클래스의 생성자를 호출하고 부모 클래스의 생성자 호출이 끝나면 자식 클래스가 추가한 부분을 초기화하기 위하여 자식 클래스의 생성자가 실행된다.

```java
class Base {
    Base() {
        System.out.println("Base() 생성자 호출");
    }
};

class Derived extends Base {
    Derived() {
        System.out.println("Derived() 생성자 호출");
    }
};

public class Test {
    public static void main(String args[]) {
        Derived obj = new Derived();
    }
}
/*
Base() 생성자 호출
Derived() 생성자 호출
 */
```

### 명시적인 호출

- 키워드 super를 이용해 자식 클래스의 생성자에서 명시적으로 부모 클래스의 생성자를 호출할 수 있다.

```java
class Base {
    Base() {
        System.out.println("Base() 생성자 호출");
    }
};

class Derived extends Base {
    Derived() {
        super();
        System.out.println("Derived() 생성자 호출");
    }
};

public class Test {
    public static void main(String args[]) {
        Derived obj = new Derived();
    }
}
/*
Base() 생성자 호출
Derived() 생성자 호출
 */
```

### 묵시적인 호출

- 자바에서는 명시적으로 부모 클래스의 생성자를 호출하지 않아도 자식 클래스의 객체가 생성될 때 자동으로 부모 클래스의 기본 생성자가 호출된다. 

```java
class Base {
    Base() {
        System.out.println("Base() 생성자 호출");
    }
};

class Derived extends Base {
    Derived() {
        System.out.println("Derived() 생성자 호출");
    }
};

public class Test {
    public static void main(String args[]) {
        Derived obj = new Derived();
    }
}
/*
Base() 생성자 호출
Derived() 생성자 호출
 */
```
### 오류가 발생하는 경우

- 묵시적인 부모 클래스 생성자 호출을 사용하려면 부모 클래스에 매개변수가 없는 기본 생성자가 반드시 정의되어 있거나 생성자가 명시적으로 정의되지 않아야 한다.

```java
// 기본 생성자가 정의된 경우
class Base {
    Base() {
        System.out.println("Base() 생성자 호출");
    }
};

class Derived extends Base {
    Derived() {
        System.out.println("Derived() 생성자 호출");
    }
};

public class Test {
    public static void main(String args[]) {
        Derived obj = new Derived();
    }
}
/*
Base() 생성자 호출
Derived() 생성자 호출
 */
```

```java
// 생성자가 명시적으로 정의되지 않아 기본 생성자가 자동으로 생성되는 경우
class Base {
};

class Derived extends Base {
    Derived() {
        System.out.println("Derived() 생성자 호출");
    }
};

public class Test {
    public static void main(String args[]) {
        Derived obj = new Derived();
    }
}
/*
Derived() 생성자 호출
 */
```

````java
// Base 클래스에는 이미 int 형의 인수를 가지는 생성자가 선언되어 있어서 컴파일러가 기본 생성자를 만들지 않으므로 오류가 발생한다.
// 이를 해결하기 위해 키워드 super로 명시적으로 자식 클래스의 생성자 첫 부분에 부모 클래스의 생성자를 호출하는 문장을 넣어야 한다.
class Base {
    Base(int x) {
        System.out.println("Base() 생성자 호출");
    }
};

class Derived extends Base {
    Derived() {
        // super(100);
        System.out.println("Derived() 생성자 호출");
    }
};

public class Test {
    public static void main(String args[]) {
        Derived obj = new Derived();
    }
}
/*
error
 */
````

### 부모 클래스의 생성자 선택

- 부모 클래스에 여러 개의 생성자가 정의된 경우 키워드 super의 인자에 들어가는 매개변수의 수를 통해 부모 클래스의 생성자를 선택한다.

```java
class Base {
    Base() {
        System.out.println("Base() 생성자 호출");
    }

    Base(int x) {
        System.out.println("Base(int x) 생성자 호출");
    }
};

class Derived extends Base {
    Derived() {
        super(100);
        System.out.println("Derived() 생성자 호출");
    }
};

public class Test {
    public static void main(String args[]) {
        Derived obj = new Derived();
    }
}
/*
Base(int x) 생성자 호출
Derived() 생성자 호출
*/
```

예제 6-4 Person 클래스와 Student 클래스 만들어보기

````java
class Person {
    String name;
    public Person() { };
    public Person(String name) {
        this.name = name;
    }
}

class Employee extends Person {
    String id;
    public Employee() {
        super();
    }

    public Employee(String name) {
        super(name);
    }

    public Employee(String name, String id) {
        super(name);
        this.id = id;
    }
}

public class EmployeeTest {
    public static void main(String args[]) {
        Employee obj = new Employee("Sewon", "2022440025");

        System.out.println("Employ [id: " + obj.id + ", name: " + obj.name + "]"); // Employ [id: 2022440025, name: Sewon]
    }
}
````

## 6.4 메소드 오버라이딩

## 6.5 다형성

## 6.6 상속 vs 구성

