# Midterm

- 자바는 엄격한 자료형 검사를 하는 언어다.(동적 자료형(파이썬) vs 정적 자료형(자바))
- 변수 선언은 변수의 자료형과 변수의 이름을 적는 것이다.
- 자바에서 모든 문장은 ;으로 끝나야 한다.
- 자바프로그램에는 적어도 하나의 클래스가 반드시 필요하다.
- 소스 안에 public 클래스가 하나 있다면 반드시 소스 파일의 이름은 public 클래스의 이름과 동일해야 한다. 다른 클래스는 public 클래스가 아니어야 한다.
- 만양 하나의 소스 파일 안에 public 클래스가 없다면 소스 파일 안에 포함된 어떤 클래스의 이름으로 하여도 상관 없다.
- 인수는 메소드의 매게변수로 전달된다.
- static 키워드: 객체를 생성하지 않아도 메소드를 호출할 수 있도록 한다.
- 하나의 자바 프로그램에는 main() 메소드를 가지고 있는 클래스가 반드시 하나는 있어야 한다.
- main() 메소드에서 자바 프로그램의 실행이 시작되며 첫 번째 문장부터 순차적으로 실행되다가 main()의 마지막 문장을 실행한 후에 종료된다.
- 문장은 사용자가 컴퓨터에게 작업을 지시하는 단위다.
- 프로그램의 한 줄이 하나의 문장이 된다.
- 주석은 프로그램의 실행에 영향을 끼치지 않는다.

---

- 변수는 사용자가 입력한 값을 저장하거나 계산 도중에 중간 결과를 저장할 때 사용되기도 한다.
- 변수 선언을 하면 컴파일러는 변수의 자료형에 맞는 기억 공간을 미리 확보한다.
- 식별자: 클래스, 메소드, 변수의 이름
- 식별자 규칙

1. 알파벳 문자, 숫자, 밑줄 문자(_), 한글로 이루어진다.
2. 첫 번째 문자는 알파벳 또는 밑줄 문자(_)이어야 한다.
3. 특수문자(%, &, #)는 사용할 수 없다. 단, $와 _는 가능하다.
4. 대문자와 소문자는 구별한다.
5. 키워드는 사용할 수 없다.

- 식별자 관례

1. 클래스명: PascalCase
2. 변수명, 메소드명: camelCase
3. 상수: 대문자

- 메소드 명을 지을 때는 첫 단어로 동사나 형용사를 쓴다.
- 자바에는 기초형과 참조형 자료형이 있다.
- 기초형은 정수형, 실수형, 문자형, 논리형이 있고 참조형에는 클래스, 배열, 인터페이스가 있다.
- 기초형 변수에는 변수의 값이 저장되지만 참조형 변수에는 객체를 참조할 수 있는 값인 객체의 주소가 저장된다.
- 자료형마다 처리할 수 있는 범위가 다르기 때문에 메모리 공간을 효과적으로 사용하려면 처리하는 값의 범위에 따라 적절한 자료형을 선택하면 된다.

| 자료형     | 설명       | 크기(바이트) | 범위                 |
|---------|----------|---------|--------------------|
| byte    | 부호 있는 정수 | 1       | -128 ~ 127         |
| short   | 부호 있는 정수 | 2       | -256 ~ 255         |
| int     | 부호 있는 정수 | 4       | -2^32 ~ (2^31 - 1) |
| long    | 부호 있는 정수 | 8       | -2^64 ~ (2^63 - 1) |
| float   | 부동소수점형   | 4       ||
| double  | 부동소수점형   | 8       ||
| char    | 문자형      | 2       ||
| boolean |논리형| 1       | true or false      |

- 부호 있는 정수 타입의 대표형은 int이고, 부동소수점형의 대표형은 float이다.
- 위 표는 외워야 한다.
- C언어와 다르게 모든 자료형의 크기가 고정되어 있다.
- 부동소수점형 변수의 최대값과 최소값은 알기 어렵지만 부호 있는 정수의 최대값과 최소값은 알아야 한다.
- 문자형 char는 하나의 문자를 저장할 수 있다.
- 영문자든지 한글 문자든지 상관 없이 하나의 문자는 항상 2바이트다.
- 특수 문자들은 문자 앞에 역슬래쉬(\)를 사용한다.
- 자바에서 문자열은 기초형이 아니다.
- 리터럴은 소스 코드에 직접 쓰여 있는 값이다.
- 정수형 리터럴을 표현할 때, 16진수는 접두사 0x, 8진수는 접두사 0, 2진수는 접두사 0b를 사용한다.
- 정수형 리터럴 안에 밑줄 기호가 포함될 수 있는데 컴파일러는 _를 무시한다.
- 부동소수점형 리터럴은 300000 같은 일반 표기법이나 3e5과 같은 지수 표기법으로 표현할 수 있다.
- 부동소수점형 리터럴은 double 형이 기본이다.
- 부동소수점형 리터럴을 float형 변수에 저장하면 오류다.
- 논리형은 true 또는 false만을 가질 수 있다.
- final 키워드: 변수에 값이 대입되고 나면 변수의 값이 더 이상 변경되지 않는다.
- 내장된 문자열 자료형이 없다.
- String 객체들을 + 연산을 이용하여 서로 더하면 문자열이 합쳐진다.
- 변수의 값과 문자열을 합치면 변수의 값이 문자열로 자동 변환되어 합쳐진다.

## 형변환***

- Type Conversion(형변환): 하나의 자료형을 다른 자료형으로 변환하는 것

### 자동적인 형변환

- 컴퓨터에서 정수 계산 하드웨어와 실수 계산 하드웨어는 완전히 다르다.
- 컴퓨터에서는 산술적인 연산을 하기 전에 피연산자의 타입을 통일해야 한다.
- 수식을 계산할 때 가장 범위가 넓은 피연산자의 타입으로 변환해야 한다.

### 강제적인 형변환

- 형변환 연산자: 변환하려는 값의 앞에 원하는 자료형을 적는다.
- 축소 변환: 더 작은 크기의 자료형에 값을 저장하는 형변환

## 2.3 Console에서 입력받기

- next(), nextInt(), nextDouble(), nextLine()


---

# 4장

- 실제로 어떤 작업을 하려면 객체를 생성해야 한다.
- 객체 생성: 1. 참조 변수 선언 2. new 연산자로 객체를 생성하고 객체의 참조값을 참조 변수에 저장
- new 연산자: 객체를 히프 메모리(사용되지 않은 메모리)에 생성한 후에 개게의 참조값을 반환한다.
- 각 객체는 클래스에 정의된 필드의 자체 복사본을 가지고 있으므로 한 객체의 들어 있는 변수의 내용은 다른 객체에 들어 있는 변수의 내용과 다르다.

## 생성자 함수
- 생성자 함수: 객체가 생성될 때 객체를 초기화하는 특수한 메소드
- 생성자의 이름은 클래스의 이름과 같다.
- 반환값을 가지지 않는다.
- Default constructor(기본 생성자): 매개변수가 없는 생성자로 필드가 int같은 수피형 변수라면 0, 참조형 변수라면 null, 부울형 변수라면 false로 초기화한다.
- 개발자가 생성자를 하나도 정의하지 않으면 자바 컴파일러는 기본 생성자를 자동으로 만든다.
- 개발자가 생성자를 하나라도 선언하면 컴파일러는 기본 생성자를 추가하지 않는다.


## 의존
- Dependency: 하나의 클래스가 다른 클래스를 사용하는 관계

# 5장

## 5.1 객체의 생성과 소멸

- Heap Memory(히프 메모리): JVM이 가지고 있는 가용 메모리
- Garbage Collection(가비지 컬렉션): 자바에서 자동 메모리 삭제 시스템 - 어떤 객체를 참조하는 변수는 Garbage collection의 후보다. 왜냐하면 모든 객체는 참조 변수를 통해서만 사용될 수 있기 때문이다.

## 5.3 정적 멤버

- 정적 멤버: 모든 객체가 공유하는 멤버
- 인스턴스 멤버: 객체마다 별도로 소유하는 멤버
- 정적 변수는 객체 없이 클래스의 이름으로 접근할 수 있다.
- 정적 변수는 객체의 생성과 상관 없이 클래스가 자바 가상 기계에 적재되는 순간 생성되며, 객체가 사라져도 정적 변수는 소멸되지 않고, 프로그램이 종료되면 소멸된다.
- 인스턴스 변수는 객체와 함깨 생성되며 소멸된다. 
- 인스턴스 변수는 객체 생성 후에만 사용할 수 있다. 
- main()가 정적 메소드이기 때문에 자바 가상 기계가 객체를 생성할 필요 없이 main() 메소드를 호출할 수 있다. 
- 정적 변수를 사용하면 일종의 전역 변수를 만들 수 있다.
- 정적 메소드는 정적 멤버만 사용할 수 있다. -> 정적 메소드는 인스턴스 변수를 사용할 수 없으며 인스턴스 메소드를 사용할 수 없으며 정적 변수와 정적 메소드만을 사용할 수 있다.
- 상수를 정의할 때 static과 final 키워드를 동시에 사용하는 경우가 많다. 

# 6장

## 6.1 상속

- Inheritance(상속):  기존에 존재하는 클래스로부터 필드와 메소드를 이어받고 필요한 기능을 추가할 수 있는 기법
- 자식 클래스는 부모 클래스의 필드와 메소드를 마치 자기 것처럼 사용할 수 있다.

## 6.3 상속과 생성자

- 자식 클래스 객체는 부모 클래스에서 상속된 부분을 초기화하기 위하여 먼저 부모 클래싕 생장자를 호출한다.
- 자식 클래스의 객체가 생성될 때 자동적으로 부모 클래스의 기본 생성자가 호출된다.

## 6.4 메소드 오버라이딩

- 키워드 super는 상속 관계에서 부모 클래스의 메소드나 필드를 명시적으로 참조하기 위하여 사용된다. 
- 부모 클래스의 메소드를 오버라이딩한 경우에 super를 사용하면 부모 클래스의 메소드를 호출할 수 있다.

## 6.5 다형성

- 일반적으로 객체 지향 프로그래밍에서 다형성: 객체들이 같은 메시지를 받더라도 각자의 실제 타입에 따라서 서로 다른 동작을 하는 것
- Upcasting(업캐스팅): 부모 클래스 변수로 자식 클래스 객체를 참조하는 것
- Downcasting: 부모 객체를 자식 참조 변수로 참조하는 것
- 자식 클래스 중에서 부모 클래스로부터 상속받은 부분만을 사용할 수 있고 자식 클래스의 모든 필드와 메소드는 사용할 수 없다.
- 접근할 수 있는 멤버를 결정하는 것은 객체의 타입이 아니라 변수의 타입이다.
- 동적 바인딩: 오버라이드된 메소드 호출이 컴파일 시간이 아닌 실행 시간에 결정되는 메커니즘

# 7장

## 7.1 추상 클래스

- Abstract class: 완전하게 구현되어 있지 않은 메소드를 가지고 있는 클래스
- 추상 클래스로는 객체를 생성할 수 없다.
- 추상 메소드: 몸체가 없는 메소드
- 추상 클래스는 하나 이상의 추상 메소드를 가지고 있어야 한다.
- 추상 메소드는 항상 세미 콜론으로 종료되어야 한다.
- 추상 클래스를 상속받는 자식 클래스에서는 반드시 추상 메소드를 재정의해야 한다.

## 7.2 인터페이스

- 인터페이스의 용도: 추상화, 다중 상속, 느슨한 결합
- 인터페이스의 메소드는 이름과 매개 변수만 존재하고, 몸체가 없으며 세미콜론으로 종료되어야 한다.
- 인터페이스 안에서 선언되는 메소드들은 모두 묵시적으로 public abstract이다.
- 인터페이스의 모든 추상 메소드는 어떤 클래스에서 구현되어야 한다. 

## 7.3 인터페이스를 이용한 다중 상속

- 다중 상속: 하나의 클래스가 여러 개의 부모 클래스를 가지는 것
- 인터페이스에서 정의된 변수는 자동적으로 public static final이 되어 상수가 된다.

## 7.4 디폴트 메소드와 정적 메소드

- 인터페이스 개발자가 메소드의 디폴트 구현을 제공할 수 있는 기

## 7.5 중첩 클래스

- 내부 클래스: 클래스 안에 선언된 클래스
- 내부 클래스는 외부 클래스의 인스턴스  변수와 메소드를 전부 사용할 수 있다.
- 내부 클래스도 외부 클래스의 인스턴스 멤버이므로 외부 클래스 객체가 만들어져야 내부 클래스도 만들 수 있다.
- 지역 클래스: 메소드 안에 정의되는 클래스
- 지역 클래스는 abstract 또는 final로만 지정할 수 있다.
- 지역 클래스는 외부 클래스의 인스턴스 변수뿐만 아니라 메소드의 지역 변수에도 접근할 수 있다.

## 7.6 익명 클래스

- 익명 클래스: 클래스의 몸체는 정의되지만 이름이 없는 클래스
- 익명 클래스는 클래스를 정의하면서 동시에 객체를 생성한다.
- 이름이 없기 때문에 한 번만 사용 가능하다.

